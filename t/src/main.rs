use std::{fs, process::exit, env};
use colored::Colorize;
use std::collections::HashMap;
//use rand::Rng;

#[derive(Debug, Clone)]
struct ErrorInfo {
    filename: String,
    line: usize,
}

fn main() {
    let args: Vec<String> = env::args().collect();
    let filename = args[1].as_str();

    let raw_file = fs::read_to_string(filename).unwrap();
    let chars: Vec<char> = raw_file.chars().collect();

    let mut vars: HashMap<String, (usize, String, usize)> = HashMap::new();
    let mut var_ram: usize = 0x0F_0000;

    let mut asm = String::from(";Generated by the original T compiler\n\njmp .main\n\n\n");
    let mut token = String::new();
    
    let mut line = 1;
    let mut char_num = 0;

    let mut current_func = String::new();
    
    while char_num < chars.len() {
        let char = chars[char_num];

        if char == '\n' {line += 1; char_num += 1; continue;}
        else if char.is_whitespace() {char_num += 1; continue;}

        let error_info = ErrorInfo {
            filename: filename.to_string(),
            line,
        };

        token.push(char);

        if token == "//" {
            while chars[char_num] != '\n' {
                char_num += 1;
            }
            token.clear();
            continue;
        }
        else if token == "/*" {
            while chars[char_num-1] != '*' || chars[char_num] != '/'{
                char_num += 1;
            }
            token.clear();
            continue;
        }

        match token.as_str() {
            "func" => {
                token.clear();

                (token, char_num) = collect(&chars, char_num, '(');
                char_num += 1;

                asm.push_str(format!(".{}", token).as_str());
                current_func = token.clone();

                (token, char_num) = collect(&chars, char_num, ')');

                asm.push_str(format!(" ;({})\n", token).as_str());

                if token.len() > 0 {
                    let args = token.split(',');

                    for arg in args {
                        let temp: Vec<String> = arg.split(':').map(|s| s.to_string()).collect();
                        let var_name = format!("{}__FUNC:__{}___T-COMPILER___", temp[0], current_func);
                        let var_type = temp[1].clone();

                        match var_type.as_str() {
                            "u32" => {vars.insert(var_name, (var_ram, String::from("u32"), 0)); var_ram += 4}
                            "u16" => {vars.insert(var_name, (var_ram, String::from("u16"), 0)); var_ram += 2}
                            "u8" => {vars.insert(var_name, (var_ram, String::from("u8"), 0)); var_ram += 1}  
                            
        
                            _ => {
                                if !var_type.starts_with("array") {error("Unknown type".to_string(), var_type.clone(), error_info.clone())}

                                let array_properties = var_type.strip_prefix("array[").unwrap().strip_suffix("]").unwrap().split("?").collect::<Vec<&str>>();
                                let array_type = array_properties[0].trim();
                                let array_size = array_properties[1].trim().parse::<usize>().unwrap();

                                vars.insert(var_name, (var_ram, format!("array,{},{}", array_type, array_size), 0));
                         
                                match array_type {
                                    "u32" => {var_ram += array_size * 4}
                                    "u16" => {var_ram += array_size * 2}
                                    "u8" => {var_ram += array_size}

                                    _ => {error("Unknown type".to_string(), var_type.clone(), error_info.clone())}
                                }
                            }
                        }
                    }
                }

                while chars[char_num] != '{' {
                    char_num += 1;
                }
                token.clear();
            }
            "return" => {
                token.clear();

                (token, char_num) = collect(&chars, char_num, ';');
                char_num += 1;
                
                asm.push_str(resolve(token.clone(), &vars, &current_func, &error_info).as_str());

                asm.push_str("pop pc\n");
                token.clear();
            }
            "}" => {
                token.clear();
                asm.push_str("pop pc\n\n");
            }

            "asm" => {
                token.clear();

                while chars[char_num] != '{' {
                    char_num += 1;
                }

                while chars[char_num + 1] != '}' {
                    if chars[char_num] == '\n' {line += 1;}
                    char_num += 1;
                    token.push(chars[char_num]);
                }

                asm.push_str(token.as_str());
                char_num += 1;
                token.clear();
            }
            "let" => {
                token.clear();
                
                (token, char_num) = collect(&chars, char_num, ':');
                let org_name = token.clone();
                let var_name = format!("{}__FUNC:__{}___T-COMPILER___", token.clone(), current_func);
            
                token.clear();
                char_num += 1;

                (token, char_num) = collect(&chars, char_num, '=');
                let var_type = token.clone();
            
                token.clear();
                char_num += 1;

                (token, char_num) = collect(&chars, char_num, ';');
                char_num += 1;
                let equation = token.clone();
                asm.push_str(resolve(token.clone(), &vars, &current_func, &error_info).as_str());

                match var_type.as_str() {
                    "u32" => {vars.insert(var_name, (var_ram, String::from("u32"), 0)); asm.push_str(format!("sto ay {:#08X} ;{} = {}\n", var_ram, org_name, equation).as_str()); var_ram += 4}
                    "u16" => {vars.insert(var_name, (var_ram, String::from("u16"), 0)); asm.push_str(format!("mov ay cx\nsto cx {:#08X} ;{} = {}\n", var_ram, org_name, equation).as_str()); var_ram += 2}
                    "u8" => {vars.insert(var_name, (var_ram, String::from("u8"), 0)); asm.push_str(format!("ubs ay {:#08X} ;{} = {}\n", var_ram, org_name, equation).as_str()); var_ram += 1}      

                    _ => {
                        if !var_type.starts_with("array") {error("Unknown type".to_string(), var_type.clone(), error_info.clone())}

                        let var_type_err_msg = var_type.clone();

                        let array_properties = var_type.strip_prefix("array[").unwrap().strip_suffix("]").unwrap().split("?").collect::<Vec<&str>>();
                        let array_type = array_properties[0].trim();
                        let array_size = array_properties[1].trim().parse::<usize>().unwrap();

                        let values = token.strip_prefix("[").unwrap_or_else(|| {error("Mismatched types".to_string(), var_type_err_msg, error_info.clone()); exit(0);}).strip_suffix("]").unwrap().split(",").map(|s| s.to_string()).collect::<Vec<String>>();
                        
                        let mut index = 0;
                        for value in values {
                            asm.push_str(&resolve(value.clone(), &vars, &current_func, &error_info));
                            match array_type {
                                "u32" => {asm.push_str(&format!("sto ay {:#08X} ;{}[{}] = {}\n", var_ram + index, org_name, index/4, value)); index += 4}
                                "u16" => {asm.push_str(&format!("mov ay cx\nsto cx {:#08X} ;{}[{}] = {}\n", var_ram + index, org_name, index/2, value)); index += 2}
                                "u8" => {asm.push_str(&format!("ubs ay {:#08X} ;{}[{}] = {}\n", var_ram + index, org_name, index, value)); index += 1}
    
                                _ => {error("Unknown type".to_string(), var_type.clone(), error_info.clone())}
                            }
                        } 

                        vars.insert(var_name, (var_ram, format!("array,{},{}", array_type, array_size), index));
                         
                        match array_type {
                            "u32" => {var_ram += array_size * 4}
                            "u16" => {var_ram += array_size * 2}
                            "u8" => {var_ram += array_size}

                            _ => {error("Unknown type".to_string(), var_type.clone(), error_info.clone())}
                        }
                    }
                }
                token.clear();
            }
            "reg" => {
                token.clear();
                (token, char_num) = collect(&chars, char_num, '=');
                char_num += 1;
                let reg = token.clone();

                token.clear();
                (token, char_num) = collect(&chars, char_num, ';');
                char_num += 1;
                let equation = token.clone();
                asm.push_str(resolve(token.clone(), &vars, &current_func, &error_info).as_str());

                asm.push_str(&format!("mov ay {} ;{} = {}\n", reg, reg, equation));

                token.clear();
            }

            _ => {
                if token.ends_with(");") {
                    asm.push_str(&resolve(token.clone(), &vars, &current_func, &error_info));
                    token.clear();
                }
                else if token.contains(";") /*&& !token.ends_with(";")*/ {
                    error(String::from("Something is wrong"), token.clone(), error_info.clone())
                }
            }
        }
        char_num += 1;
    }
    fs::write(args[2].as_str(), asm).unwrap();

    //succes();
}

fn resolve(statement: String, vars: &HashMap<String, (usize, String, usize)>, current_func: &str, error_info: &ErrorInfo) -> String {
    let mut asm = String::new();

    if statement.parse::<u32>().is_ok() {
        asm.push_str(format!("ldi ay {}\n", statement.parse::<u32>().unwrap()).as_str());
    }
    else if statement.starts_with("0x") && statement.len() > 2 {
        asm.push_str(format!("ldi ay {:#08X}\n", u32::from_str_radix(&statement[2..].replace("_", ""), 16).unwrap()).as_str());
    }
    else if statement.starts_with("0b") && statement.len() > 2 {
        asm.push_str(format!("ldi ay {}\n", u32::from_str_radix(&statement[2..].replace("_", ""), 2).unwrap()).as_str());
    }
    else if statement.contains("(") {
        let chars: Vec<char> = statement.chars().collect();
        let mut token = String::new();

        for char in chars.clone() {
            if char == '(' {break}
            token.push(char);
        }
        let func_name = token.clone();
        token.clear();

        let mut char_num = 0;
        while chars[char_num] != '(' {
            char_num += 1;
        }
        let args = collect(&chars, char_num, ')').0;

        if args.len() > 0 {
            let args: Vec<String> = args.split(',').map(|s| s.to_string()).collect();
            
            for arg in args {
                let temp: Vec<String> = arg.split(':').map(|s| s.to_string()).collect();
                if temp.len() < 2 {error(String::from("Incomplete argument"), temp[0].clone(), error_info.clone())}
  
                let var = temp[1].clone();
                let dest_var = temp[0].clone();
                asm.push_str(&resolve(var, &vars, &current_func, &error_info));

                let key = format!("{}__FUNC:__{}___T-COMPILER___", dest_var, func_name);
                if !vars.contains_key(&key) {error(String::from("Argument not requested"), dest_var.clone(), error_info.clone())}
                
                let temp = vars.get(&key).unwrap();
                let addr: usize = temp.0;
                let var_type: String = temp.1.clone();

                match var_type.as_str() {
                    "u32" => {asm.push_str(&format!("sto ay {:#08X}\n", addr))}
                    "u16" => {asm.push_str(&format!("mov ay cx\nsto cx {:#08X}\n", addr))}
                    "u8" => {asm.push_str(&format!("ubs ay {:#08X}\n", addr))}

                    _ => {
                        if !var_type.starts_with("array") {error("Unknown type".to_string(), var_type.clone(), error_info.clone())}

                        let temp = var_type.split(",").collect::<Vec<&str>>();
                        let array_type = temp[1].clone();
                        let mut array_size = temp[2].parse::<usize>().unwrap();

                        match array_type  {
                            "u32" => {array_size *= 4}
                            "u16" => {array_size *= 2}

                            _ => {}
                        }

                        if array_size < 6 {
                            let mut index = 0;
                            while index < array_size {
                                asm.push_str(&format!("pop ax\nubs ax {:#08X}\n", addr - index + array_size - 1));

                                index += 1;
                            }
                        }
                        else {
                            let id = rand::random::<u64>();

                            asm.push_str(&format!("ldi cr 0\nldi by {:#08X}\nldi ar {:#08X}\n.loading_loop_id:_{:#08X}\ncmp .exit_loop_id:_{:#08X}\npop ax\nsbr ax 0 ar\ninc cr\ninc ar\njmp .loading_loop_id:_{:#08X}\n.exit_loop_id:_{:#08X}\n", array_size, addr, id, id, id, id));
                        }
                    }
                }
            }
        }   
        asm.push_str(&format!("mov pc ar\nldi ax 16\nadd ax\npsh ar\njmp .{} ;{}\n", func_name, statement));
    }
    else if statement.contains("[") {
        if statement.starts_with("[") {
            /*let values = statement.strip_prefix("[").unwrap().strip_suffix("]").unwrap().split(",").map(|s| s.to_string()).collect::<Vec<String>>();

            for value in values {
                // Do nothing.
            }*/
        }
        else {
            let chars = statement.chars().collect::<Vec<char>>();
            let mut token = String::new();

            let mut i = 0;
            while chars[i] != '[' {
                if chars[i].is_whitespace() {continue}
                token.push(chars[i]);
                i += 1;
            }
            let var_name = token;

            let key = format!("{}__FUNC:__{}___T-COMPILER___", &var_name, &current_func);
                
            if !vars.contains_key(&key) {error(String::from("Variable not found"), statement.clone(), error_info.clone())}
        
            let temp = vars.get(&key).unwrap();
            let addr: usize = temp.0;
            let var_type: String = temp.1.clone();

            let temp = var_type.split(",").collect::<Vec<&str>>();
            let array_type = temp[1].clone();
            //let array_size = temp[2].parse::<usize>().unwrap();

            let index = collect(&statement.strip_prefix(&var_name).unwrap().chars().collect(), 0, ']').0;

            if index.parse::<usize>().is_ok() {
                let index = index.parse::<usize>().unwrap();

                match array_type {
                    "u32" => {asm.push_str(&format!("lod ay {:#08X}\n", addr + (index * 4)))}
                    "u16" => {asm.push_str(&format!("lod cx {:#08X}\nmov cx ay\n", addr + (index * 2)))}
                    "u8" => {asm.push_str(&format!("ubl ay {:#08X}\n", addr + (index * 1)))}

                    _ => {}
                }  
            }
            else {
                asm.push_str(&resolve(index, &vars, &current_func, &error_info));

                match array_type {
                    "u32" => {asm.push_str(&format!("ldi ax 4\nmul ar\nmov ar ax\nldi ar {:#08X}\nadd ax\nlor ay 0 ar\n", addr))}
                    "u16" => {asm.push_str(&format!("ldi ax 2\nmul ar\nmov ar ax\nldi ar {:#08X}\nadd ax\nlor ay 0 ar\n", addr))}
                    "u8" => {asm.push_str(&format!("ldi ar {:#08X}\nadd ay\nlor ay 0 ar\n", addr))}

                    _ => {}
                } 
            }
        }
    }
    else if !(statement.contains("(") || statement.contains("+") || statement.contains("-") || statement.contains("*") || statement.contains("/")) {
        let key = format!("{}__FUNC:__{}___T-COMPILER___", &statement, &current_func);

        if !vars.contains_key(&key) {error(String::from("Variable not found"), statement.clone(), error_info.clone())}
        
        let temp = vars.get(&key).unwrap();
        let addr: usize = temp.0;
        let var_type: String = temp.1.clone();
        //let index: usize = temp.2.clone();

        match var_type.as_str() {
            "u32" => {asm.push_str(&format!("lod ay {:#08X}\n", addr))}
            "u16" => {asm.push_str(&format!("lod cx {:#08X}\nmov cx ay\n", addr))}
            "u8" => {asm.push_str(&format!("ubl ay {:#08X}\n", addr))}

            _ => {
                if !var_type.starts_with("array") {error("Unknown type".to_string(), var_type.clone(), error_info.clone())}

                let temp = var_type.split(",").collect::<Vec<&str>>();
                let array_type = temp[1].clone();
                let mut array_size = temp[2].parse::<usize>().unwrap();

                match array_type  {
                    "u32" => {array_size *= 4}
                    "u16" => {array_size *= 2}

                    _ => {}
                }

                if array_size < 6 {
                    let mut index = 0;
                    while index < array_size {
                        
                        asm.push_str(&format!("ubl ax {:#08X}\npsh ax\n", addr + index));

                        index += 1;
                    }
                }
                else {
                    let id = rand::random::<u64>();

                    asm.push_str(&format!("ldi cr 0\nldi by {:#08X}\nldi ar {:#08X}\n.loading_loop_id:_{:#08X}\ncmp .exit_loop_id:_{:#08X}\nlbr ax 0 ar\npsh ax\ninc cr\ninc ar\njmp .loading_loop_id:_{:#08X}\n.exit_loop_id:_{:#08X}\n", array_size, addr, id, id, id, id));
                }
            }
        }
    }
    
    else {
        let mut values: Vec<String> = Vec::new();
        let mut operators: Vec<char> = Vec::new();

        let mut token = String::new();

        for char in statement.chars() {
            if char.is_whitespace() {continue}
            match char {
                '/' => {operators.push('/'); values.push(token.clone()); token.clear()}
                '*' => {operators.push('*'); values.push(token.clone()); token.clear()}
                '+' => {operators.push('+'); values.push(token.clone()); token.clear()}
                '-' => {operators.push('-'); values.push(token.clone()); token.clear()}
                _ => {token.push(char)}
            }
        }
        values.push(token.clone());

        let mut i = 0;
        asm.push_str(&resolve(values[i].clone(), &vars, &current_func, &error_info));
        asm.push_str("mov ay ar\n");
        
        while i < operators.len() {
            asm.push_str("mov ar ax\n");
            asm.push_str(&resolve(values[i+1].clone(), &vars, &current_func, &error_info));

            match operators[i] {
                '/' => {asm.push_str("div ar\n")}
                '*' => {asm.push_str("mul ar\n")}
                '+' => {asm.push_str("add ar\n")}
                '-' => {asm.push_str("sub ar\n")}            
                _ => {}
            }

            i += 1;
        }
        asm.push_str("mov ar ay\n");
    }

    return asm;
}

fn collect(chars: &Vec<char>, mut char_num: usize, until: char) -> (String, usize) {
    let mut token = String::new();
    while chars[char_num + 1] != until {
        char_num += 1;
        if chars[char_num].is_whitespace() {continue}
        token.push(chars[char_num]);
    }
    return (token, char_num);
}

fn error(msg: String, additional: String, error_info: ErrorInfo) {
    println!("\n{}: {}: {} ({})\n", "Error".bright_red().bold(), format!("{} at", msg).bright_yellow(), format!("{}:{}", error_info.filename, error_info.line).bright_blue().underline(), additional.to_uppercase().red());
    exit(0);
}

fn succes() {
    println!("\n{}\n", format!("
   /$$$$$$$$$$                                                 /$$ /$$                    
  |___  $$___/                                                |__/| $$                    
      | $$          /$$$$$$$  /$$$$$$  /$$$$$$/$$$$   /$$$$$$  /$$| $$  /$$$$$$   /$$$$$$ 
      | $$         /$$_____/ /$$__  $$| $$_  $$_  $$ /$$__  $$| $$| $$ /$$__  $$ /$$__  $$
      | $$        | $$      | $$  \\ $$| $$ \\ $$ \\ $$| $$  \\ $$| $$| $$| $$$$$$$$| $$  \\__/
      | $$        | $$      | $$  | $$| $$ | $$ | $$| $$  | $$| $$| $$| $$_____/| $$      
      | $$        |  $$$$$$$|  $$$$$$/| $$ | $$ | $$| $$$$$$$/| $$| $$|  $$$$$$$| $$      
      |__/         \\_______/ \\______/ |__/ |__/ |__/| $$____/ |__/|__/ \\_______/|__/      
                                                    | $$                                  
   {}                                     | $$                                  
                                                    |__/                                  ",
    "The original".purple().bold()).bright_green().bold());
}
